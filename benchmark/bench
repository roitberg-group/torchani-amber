#!/usr/bin/env python
from copy import deepcopy
import os
import sys
import time
import csv
import shutil
import subprocess
import uuid
import json
import hashlib
import typing_extensions as tpx
from typer import Option
import itertools
from enum import Enum
import typing as tp
import dataclasses
from pathlib import Path

from rich.console import Console
from typer import Typer, Abort
import jinja2

console = Console()
app = Typer()

this_dir = Path(__file__).parent
systems_dir = this_dir / "systems"


@dataclasses.dataclass
class BenchMlmmConfig:
    protocol: str = "ani_me"
    use_torch_coupling: bool = True
    cuda: bool = True
    ml_system_selection: str = ":1"
    float64: bool = True


def flatten_dict(d: tp.Dict[str, tp.Any], prefix: str = "") -> tp.Dict[str, tp.Any]:
    flat_d = {}
    for oldk, v in d.items():
        k = f"{prefix}{oldk}"
        if isinstance(v, dict):
            flat_d.update(flatten_dict(v, f"{k}."))
        else:
            flat_d[k] = v
    return flat_d


def as_flat_dict(datacls_obj) -> tp.Dict[str, tp.Any]:
    return flatten_dict(dataclasses.asdict(datacls_obj))


class Protocol(Enum):
    ANI_ME = "ani_me"
    SANDER_ME = "sander_me"
    ANI_MBISPOL = "ani_mbispol"
    ANI_ME_MBIS = "ani_me_mbis"
    SANDER_ME_MBIS = "sander_me_mbis"
    ANI_MBISPOL_NOGRADQ = "ani_mbispol_nogradq"


@dataclasses.dataclass
class BenchConfig:
    system: str = "ala-8-chain"
    replica: int = 0
    tstep_num: int = 500
    core_num: int = 1
    mlmm: tp.Optional[BenchMlmmConfig] = None

    @property
    def name(self) -> str:
        return f"{self.shorthash}-replica-{str(self.replica).zfill(2)}"

    @property
    def shorthash(self) -> str:
        hasher = hashlib.shake_128()
        dict_ = dataclasses.asdict(self)
        dict_.pop("replica")
        # Bw compat, don't include this field in the hash if using ala-8-chain
        if dict_["system"] == "ala-8-chain":
            dict_.pop("system")
        hasher.update(json.dumps(dict_).encode("utf-8"))
        return hasher.hexdigest(8)


@app.command()
def run(
    slurm: tpx.Annotated[
        bool,
        Option(
            "--slurm/--no-slurm",
            help="Generate a sbatch file and execute it (specific for HPG)",
        ),
    ] = False,
    system: tpx.Annotated[
        str,
        Option(
            "--system",
            help="Name of system to run on. Must be found in 'benchmark/systems'",
        ),
    ] = "ala-8-chain",
    replica_num: tpx.Annotated[
        int,
        Option(
            "-r",
            "--replicas",
            help="Number of times to run benchmark for each config",
        ),
    ] = 5,
    bench_me: tpx.Annotated[
        bool,
        Option("--bench-me/--no-bench-me"),
    ] = True,
    bench_mbispol: tpx.Annotated[
        bool,
        Option("--bench-mbispol/--no-bench-mbispol"),
    ] = True,
    bench_sander_me: tpx.Annotated[
        bool,
        Option("--bench-sander-me/--no-bench-sander-me"),
    ] = False,
    bench_mbispol_nogradq: tpx.Annotated[
        bool,
        Option("--bench-mbispol-nogradq/--no-bench-mbispol-nogradq "),
    ] = False,
    bench_me_mbis: tpx.Annotated[
        bool,
        Option("--bench-me-mbis/--no-bench-me-mbis"),
    ] = False,
    cpu: tpx.Annotated[
        bool,
        Option("--cpu/--no-cpu", help="Benchmark on CPU"),
    ] = False,
    cuda: tpx.Annotated[
        bool,
        Option("--cuda/--no-cuda", help="Benchmark on CUDA device"),
    ] = True,
    core_num: tpx.Annotated[
        int,
        Option(
            "-c",
            "--cores",
            help="Number of cores to run benchmark on, if > 1 sander.MPI is used",
        ),
    ] = 1,
    tstep_num: tpx.Annotated[
        int,
        Option(
            "-t",
            "--tsteps",
            help="Number of timesteps to run benchmark for",
        ),
    ] = 500,
    bench_dir: tpx.Annotated[
        tp.Optional[Path],
        Option(
            "-b",
            "--bench-dir",
            show_default=False,
            help="Full path to benchmark directory."
            " Created automatically by default, so no need to use this opt in general",
        ),
    ] = None,
    selections: tpx.Annotated[
        tp.Optional[tp.List[str]],
        Option(
            "-s",
            "--selection",
            help="'Ambermask' that determines which part of the system is QM."
            " If specified multiple times multiple configs are run"
            " each with a different selection",
        ),
    ] = None,
    verbose: tpx.Annotated[
        bool,
        Option("-v/-V", "--verbose/--no-verbose"),
    ] = True,
) -> None:
    r"""Run Sander or Sander-MPI ML/MM benchmarks"""
    if bench_dir is None:
        kind = "serial" if core_num == 1 else "mpi"
        dirname = f"{kind}-bench-{str(uuid.uuid4()).split('-')[0]}"
        bench_dir = this_dir / dirname
        bench_dir.mkdir()

    env = jinja2.Environment(
        loader=jinja2.FileSystemLoader(Path(__file__).parent / "templates/"),
        undefined=jinja2.StrictUndefined,
        autoescape=jinja2.select_autoescape(),
        trim_blocks=True,
        lstrip_blocks=True,
    )
    if slurm:
        arg_list = sys.argv[1:]
        for j, arg in enumerate(deepcopy(arg_list)):
            if arg in ["-s", "--selection", "--system"]:
                # re-introduce quotes in the selections and system
                arg_list[j + 1] = f"'{arg_list[j + 1]}'"
        args = " ".join(arg_list)
        args = args.replace(" --slurm", "")
        tmpl = env.get_template("bench.slurm.sh.jinja").render(
            cli_app_dir=str(this_dir),
            core_num=core_num,
            args=args,
            bench_dir=str(bench_dir),
        )
        input_fpath = bench_dir / "hpg.slurm.sh"
        input_fpath.write_text(tmpl)
        console.print("Launching slurm script ...")
        subprocess.run(["sbatch", str(input_fpath)], cwd=bench_dir, check=True)
        sys.exit(0)

    protos = []
    if bench_me:
        protos.append(Protocol.ANI_ME)
    if bench_sander_me:
        protos.append(Protocol.SANDER_ME)
    if bench_mbispol:
        protos.append(Protocol.ANI_MBISPOL)
    if bench_me_mbis:
        protos.extend([Protocol.ANI_ME_MBIS, Protocol.SANDER_ME_MBIS])
    if bench_mbispol_nogradq:
        protos.append(Protocol.ANI_MBISPOL_NOGRADQ)
    replicas = list(range(replica_num))
    if selections is None:
        selections = [":5", ":4-6", ":3-7", ":2-8", ":1-9"]
    benchmark(
        bench_dir,
        replicas,
        selections,
        protos,
        cuda,
        cpu,
        env,
        tstep_num,
        core_num,
        replica_num,
        system,
        verbose,
    )


def benchmark(
    bench_dir: Path,
    replicas: tp.List[int],
    selections: tp.List[str],
    protocols: tp.Sequence[Protocol],
    cuda: bool,
    cpu: bool,
    env: jinja2.Environment,
    tstep_num: int,
    core_num: int,
    total_replicas: int,
    system: str,
    verbose: bool,
) -> None:
    couple_bools = (True, False)
    dev_bools = []
    if cuda:
        dev_bools.append(True)
    if cpu:
        dev_bools.append(False)
    if not dev_bools:
        console.print("At least one of '--cpu' or '--cuda' has to be specified")

    # Base, "MM/MM" config
    configs = [
        BenchConfig(replica=idx, core_num=core_num, tstep_num=tstep_num, system=system)
        for idx in replicas
    ]
    for idx, proto, torchcouple, cuda, selection in itertools.product(
        replicas, protocols, couple_bools, dev_bools, selections
    ):
        if torchcouple and proto in [Protocol.SANDER_ME, Protocol.SANDER_ME_MBIS]:
            continue
        configs.append(
            BenchConfig(
                replica=idx,
                core_num=core_num,
                tstep_num=tstep_num,
                system=system,
                mlmm=BenchMlmmConfig(proto.value, torchcouple, cuda, selection),
            )
        )

    if verbose:
        ms_to_s = 1 / 1000
        s_to_hr = 1 / 3600
        s_to_min = 1 / 60
        configs_per_replica = len(configs) / len(replicas)
        console.print(f"Will run {total_replicas} total replicas")
        console.print(
            f"Will use {core_num} cores ({'serial' if core_num == 1 else 'mpi'})"
        )
        console.print(f"Will benchmark {len(configs)} configs total")
        console.print(f"Will benchmark {int(configs_per_replica)} configs per replica")
        console.print(f"Will run each config for {tstep_num} steps")
        estimate_ms = len(configs) * 400 * tstep_num / core_num
        estimate_hs = estimate_ms * ms_to_s * s_to_hr
        if estimate_hs < 1:
            factor = s_to_min
            unit = "min"
        else:
            factor = s_to_hr
            unit = "hr"
        console.print(
            f"Assuming ~400 ms/step/core on average"
            f" the time estimate is"
            f" {estimate_ms / total_replicas * ms_to_s * factor:.2f} {unit}"
            f" for a single replica"
            f" and {estimate_ms * ms_to_s * factor:.2f} {unit} in total"
        )

    results_fpath = bench_dir / f"{bench_dir.name}-results.csv"
    with open(
        results_fpath,
        mode="wt",
        encoding="utf-8",
    ) as f:
        any_config_keys = list(as_flat_dict(configs[-1]).keys())
        any_config_keys.insert(0, "id")
        any_config_keys.append("walltime_ns")
        writer = csv.DictWriter(f, fieldnames=any_config_keys)
        writer.writeheader()
        for config_idx, config in enumerate(configs):
            input_as_str = env.get_template("mlmm.mdin.jinja").render(
                **dataclasses.asdict(config)
            )
            config_dir = bench_dir / config.name
            config_dir.mkdir()
            shutil.copy(systems_dir / f"{config.system}.inpcrd", config_dir / "inpcrd")
            shutil.copy(systems_dir / f"{config.system}.prmtop", config_dir / "prmtop")
            (config_dir / "mdin").write_text(input_as_str)
            cmd = (
                ["sander"]
                if config.core_num == 1
                else ["mpirun", "-n", str(config.core_num), "sander.MPI"]
            )
            if verbose:
                console.print(f"{config_idx}/{len(configs)} Running {config}")
            _start = time.perf_counter_ns()
            subprocess.run(cmd, cwd=config_dir, check=True)
            _end = time.perf_counter_ns()
            config_dict = as_flat_dict(config)
            if "mlmm" in config_dict:
                config_dict.pop("mlmm")
                config_dict["mlmm.protocol"] = "full_mm"
            config_dict["walltime_ns"] = _end - _start
            config_dict["id"] = config.shorthash
            writer.writerow({k: str(v) for k, v in config_dict.items()})
            # Ensure data is written to files
            f.flush()
            os.fsync(f.fileno())


@app.command()
def plot() -> None:
    console.print("Not implemented yet")
    raise Abort()


if __name__ == "__main__":
    app()
